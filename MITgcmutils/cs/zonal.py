import numpy as np

def zonalKernel(csgrid,ny):
    '''Construct a kernel for zonal averaging of data on cube-sphere grid.
    
    Input arguments:
        csgrid: a dictionary of grid data, as generated by MITgcmutils.rdmnc()
        ny:   Number of evenly spaces latitude lines to average onto
        
    Output arguments:
        kernel:  Kernel array for zonal averaging (ny,nr,nc,6*nc)
        ylat:    Latitude coordinates for zonal average data
        areazon: Area associated with zonal band.
        
    Usage:
        import MITgcmutils as mit
        grid = mit.rdmnc('grid.*')
        ny = 60
        kernel, ylat, areazon = mit.cs.zonalKernel(grid,ny)
        # to take a zonal average:
        #  field is array as created by mit.rdmnc()
        #  field.shape = (nr,nc,6*nc)
        zon = np.sum(kernel*field,axis=(2,3))
        # zon.shape = (ny,nr)
    
    Author:
        Brian Rose, University at Albany
    
    Based on matlab code calcZonalAvgCuge.m (original authors: JMC and Daniel Enderton).
    '''
    ar = csgrid['rA']  # area of grid cells
    hc = csgrid['HFacC']
    yc = csgrid['YC']
    
    nc = np.size(yc,axis=0) # size of cube face
    nr = np.size(hc,axis=0)  # number of vertical levels
    
    # Define latitude axis (with regular spacing) to average to.
    dy = 180./ny;   ylat = (np.arange(ny)+0.5)*dy - 90.
    
    # Compute zonal line weights.
    nMax = 6*nc*3           # Max number of cells near zonal line
    #ijzav = np.zeros((ny,nMax), dtype=int)  # Index of cells near band line (within dy)
    izav = np.zeros((ny,nMax), dtype=int)  # first index of cells near band line (within dy)
    jzav = np.zeros((ny,nMax), dtype=int)  # second index of cells near band line (within dy)
    alzav = np.zeros((ny,nMax))  # Area weights for cells near band line
    npzav = np.zeros(ny)     # Number of cells close to band line
    #for ij = 1:6*nc*nc                # Loop over all cells
    #for ij in range(npoints):
    for i in range(nc):
        for j in range(6*nc):
            delta = (yc[i,j]-ylat[0])/dy  # Latitude difference from bottom
            jz = 1 + np.floor(delta)              # Number of zonal lines away (round up)
            delta = delta % 1               # Fracional distance from upper line
            if jz < 1:
                n = npzav[jz] + 1   # Contribution from cell NORTH of line
                #ijzav[jz,n-1] = ij
                izav[jz,n-1] = i
                jzav[jz,n-1] = j
                alzav[jz,n-1] = 1     # Weight = 1 because all area accounted for
                npzav[jz] = n 
            elif jz >= ny:
                n = npzav[jz-1] + 1     # Contribution from cell NORTH of line
                #ijzav[jz-1,n-1] = ij
                izav[jz,n-1] = i
                jzav[jz,n-1] = j
                alzav[jz-1,n-1] = 1       # Weight = 1 because all area accounted for
                npzav[jz-1] = n
            else:
                n = npzav[jz-1] + 1;     # Contribution from cell SOUTH of line
                #ijzav[jz-1,n-1] = ij
                izav[jz-1,n-1] = i
                jzav[jz-1,n-1] = j
                alzav[jz-1,n-1] = 1 - delta
                npzav[jz-1] = n
                n = npzav[jz] + 1   # Contribution from cell NORTH of line
                #ijzav[jz,n-1] = ij
                izav[jz,n-1] = i
                jzav[jz,n-1] = j
                alzav[jz,n-1] = delta
                npzav[jz] = n
    NbMx = np.max(npzav)  # Reduce size
    #ijzav = ijzav[:,:NbMx]
    izav = izav[:,:NbMx]
    jzav = jzav[:,:NbMx]
    alzav = alzav[:,:NbMx]
    
    # Area associated with zonal lines:
    areazon = np.zeros(ny)
    for j in range(ny):
        #ijLoc = ijzav[j,:npzav[j]]
        iLoc = izav[j,:npzav[j]]
        jLoc = jzav[j,:npzav[j]]
        vvLoc = alzav[j,:npzav[j]]  #';
        areazon[j] = np.sum(vvLoc * ar[iLoc,jLoc])
    
    # in matlab code, mskzon was calculate in the basin block
    #  it's an area mask per basin and per level. with nBas = 0 it's identical to areazon
    #  but only for a single flat bottomed basin!
    #  will need to do more work here if we want to take proper basin averages
    #mskLoc = areazon
    
    kernel = np.zeros((ny,nr,nc,6*nc))
    for k in range(nr):
        var = ar * hc[k,:,:]
        for j in range(ny):
            iLoc = izav[j,:npzav[j]]
            jLoc = jzav[j,:npzav[j]]
            vvLoc = alzav[j,:npzav[j]]
            kernel[j,k,iLoc,jLoc] = vvLoc * var[iLoc,jLoc] / areazon[j]
    
    return kernel, ylat, areazon