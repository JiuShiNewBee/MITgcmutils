import numpy as np

def zonalAvg(field,kernel):
    '''Compute zonal average from cube sphere MITgcm data
    
    Input arguments:
        field:  Data to average zonally, as generated by MITgcmutils.rdmnc()
            Dimensions should be one of the following:
                - [nt,nr,nc,6*nc]
                - [nt,nc,6*nc]
                - [nr,nc,6*nc]
                - [nc,6*nc]
        kernel: a precomputed zonal average kernel array, 
                as generated by MITgcmutils.cs.zonalKernel()
        
    Output arguments:
        zonfield:  Zonally averaged field ([ny,nt,nr] or [ny,nt] or [ny,nr] or [ny])
    
    Author:
        Brian Rose, University at Albany
    '''
    inputShape = np.shape(field)
    
    ny = np.size(kernel,axis=0)
    nr = np.size(kernel,axis=1)
    #nc = np.size(kernel,axis=2)
    
    nt = 1
    if len(inputShape) is 2:
        # Assume that field is (nc,6*nc)
        zonfield = np.sum(kernel[0,:,:]*field,axis=(1,2))
        #  But this could be a problem if the kernel is different at different levels...
    elif len(inputShape) is 4:
        nt = inputShape[0]
        zonfield = np.empty((ny,nt,nr))
        for it in range(nt):
            zonfield[:,it,:] = np.sum(kernel * field[it,:,:,:],axis=(2,3))
    elif len(inputShape) is 3:
        if inputShape[0] != np.size(kernel,axis=1):
            nt = inputShape[0]
            zonfield = np.empty((ny,nt))
            for it in range(nt):
                zonfield[:,it] = np.sum(kernel * field[it,:,:], axis=(1,2))
        else:
            #  Treat 0th axis as vertical
            zonfield = np.sum(kernel * field,axis=(2,3))            
    else:
        raise TypeError('input field has wrong dimensions.')
    
    return zonfield
    

def zonalKernel(csgrid,ny):
    '''Construct a kernel for zonal averaging of data on cube-sphere grid.
    
    Input arguments:
        csgrid: a dictionary of grid data, as generated by MITgcmutils.rdmnc()
        ny:   Number of evenly spaces latitude lines to average onto
        
    Output arguments:
        kernel:  Kernel array for zonal averaging (ny,nr,nc,6*nc)
        ylat:    Latitude coordinates for zonal average data
        areazon: Area associated with zonal band.
        
    Usage:
        import MITgcmutils as mit
        grid = mit.rdmnc('grid.*')
        ny = 60
        kernel, ylat, areazon = mit.cs.zonalKernel(grid,ny)
        # to take a zonal average:
        #  field is cs data array as created by mit.rdmnc()
        zonfield = mit.cs.zonalAvg(field,kernel)
            
    Author:
        Brian Rose, University at Albany
    
    Based on matlab code calcZonalAvgCuge.m (original authors: JMC and Daniel Enderton).
    '''
    ar = csgrid['rA']  # area of grid cells
    hc = csgrid['HFacC']
    yc = csgrid['YC']
    
    nc = np.size(yc,axis=0) # size of cube face
    nr = np.size(hc,axis=0)  # number of vertical levels
    
    # Define latitude axis (with regular spacing) to average to.
    dy = 180./ny;   ylat = (np.arange(ny)+0.5)*dy - 90.
    
    # Compute zonal line weights.
    nMax = 6*nc*3           # Max number of cells near zonal line
    #ijzav = np.zeros((ny,nMax), dtype=int)  # Index of cells near band line (within dy)
    izav = np.zeros((ny,nMax), dtype=int)  # first index of cells near band line (within dy)
    jzav = np.zeros((ny,nMax), dtype=int)  # second index of cells near band line (within dy)
    alzav = np.zeros((ny,nMax))  # Area weights for cells near band line
    npzav = np.zeros(ny)     # Number of cells close to band line
    #for ij = 1:6*nc*nc                # Loop over all cells
    #for ij in range(npoints):
    for i in range(nc):
        for j in range(6*nc):
            delta = (yc[i,j]-ylat[0])/dy  # Latitude difference from bottom
            jz = 1 + np.floor(delta)              # Number of zonal lines away (round up)
            delta = delta % 1               # Fracional distance from upper line
            if jz < 1:
                n = npzav[jz] + 1   # Contribution from cell NORTH of line
                #ijzav[jz,n-1] = ij
                izav[jz,n-1] = i
                jzav[jz,n-1] = j
                alzav[jz,n-1] = 1     # Weight = 1 because all area accounted for
                npzav[jz] = n 
            elif jz >= ny:
                n = npzav[jz-1] + 1     # Contribution from cell NORTH of line
                #ijzav[jz-1,n-1] = ij
                izav[jz,n-1] = i
                jzav[jz,n-1] = j
                alzav[jz-1,n-1] = 1       # Weight = 1 because all area accounted for
                npzav[jz-1] = n
            else:
                n = npzav[jz-1] + 1;     # Contribution from cell SOUTH of line
                #ijzav[jz-1,n-1] = ij
                izav[jz-1,n-1] = i
                jzav[jz-1,n-1] = j
                alzav[jz-1,n-1] = 1 - delta
                npzav[jz-1] = n
                n = npzav[jz] + 1   # Contribution from cell NORTH of line
                #ijzav[jz,n-1] = ij
                izav[jz,n-1] = i
                jzav[jz,n-1] = j
                alzav[jz,n-1] = delta
                npzav[jz] = n
    NbMx = np.max(npzav)  # Reduce size
    #ijzav = ijzav[:,:NbMx]
    izav = izav[:,:NbMx]
    jzav = jzav[:,:NbMx]
    alzav = alzav[:,:NbMx]
    
    # Area associated with zonal lines:
    areazon = np.zeros(ny)
    for j in range(ny):
        #ijLoc = ijzav[j,:npzav[j]]
        iLoc = izav[j,:npzav[j]]
        jLoc = jzav[j,:npzav[j]]
        vvLoc = alzav[j,:npzav[j]]  #';
        areazon[j] = np.sum(vvLoc * ar[iLoc,jLoc])
    
    # in matlab code, mskzon was calculate in the basin block
    #  it's an area mask per basin and per level. with nBas = 0 it's identical to areazon
    #  but only for a single flat bottomed basin!
    #  will need to do more work here if we want to take proper basin averages
    #mskLoc = areazon
    
    kernel = np.zeros((ny,nr,nc,6*nc))
    for k in range(nr):
        var = ar * hc[k,:,:]
        for j in range(ny):
            iLoc = izav[j,:npzav[j]]
            jLoc = jzav[j,:npzav[j]]
            vvLoc = alzav[j,:npzav[j]]
            kernel[j,k,iLoc,jLoc] = vvLoc * var[iLoc,jLoc] / areazon[j]
    
    return kernel, ylat, areazon