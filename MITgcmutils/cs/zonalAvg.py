import numpy as np

def zonalAvg(fld,ny,csgrid):
    '''fldzon,ylat,areazon = zonalAvg(fld,ny,csgrid)
    
    Compute zonal average from cube sphere MITgcm data
    
    Input arguments:
        fld:  Data to average zonally ([6*n,n,nr,nt], [6*n,n,nr], [6*n,n])
        ny:   Number of evenly spaces latitude lines to average onto
        csgrid: a dictionary of grid data, as generated by MITgcmutils.rdmnc()
        
    Output arguments:
        fldzon:  Zonally averaged field ([ny,nr,nt], [ny,nr], [ny])
        ylat:    Latitude coordinates for zonal average data
        areazon: Area associated with zonal band.
    
    Author:
        Brian Rose, University at Albany
    
    Based on matlab code calcZonalAvgCuge.m (original authors: JMC and Daniel Enderton).
    '''

    ar = csgrid['rA']  # area of grid cells
    hc = csgrid['HFacC']
    yc = csgrid['YC']
    # Dimension information.
    dims = np.shape(fld)
    
    #  numpy orders the dimensions in reverse from matlab, and counts from zero
    nc = dims[2]  # size of cube face
    nr = 1; nt = 1; nDim = 4
    if len(dims) > 2:
        if len(np.shape(hc)) is 3:
            nr = np.size(hc,axis=0)
        if dims[1] is not nr:
            nr=1; nDim=3
        nt = np.prod(dims[:2])/nr
    
    # Reshape data ...  will put things in the same order as they are in matlab version
    #  will be faster if this is all vectorized but that can wait
    npoints = 6*nc*nc
    yc2 = np.reshape(yc, npoints )
    ar2 = np.reshape(ar, npoints )
    hc2 = np.empty((npoints,nr))
    fld2 = np.empty((npoints,nr,nt))
    for i in range(nr):
        hc2[:,i] = np.reshape(hc[i,:,:],npoints)  # does this really work? need to check if things are ordered correctly
        for t in range(nt):
            fld2[:,i,t] = np.reshape(fld[t,i,:,:],npoints)
    
    # Define latitude axis (with regular spacing) to average to.
    dy = 180./ny;   ylat = (np.arange(ny)+0.5)*dy - 90.
    
    # Define minimum area fraction (relative to full latitude band):
    frcZmn=0.05                   # ??? Why
    
    # Compute zonal line weights.
    nMax = 6*nc*3           # Max number of cells near zonal line
    ijzav = np.zeros((ny,nMax), dtype=int)  # Index of cells near band line (within dy)
    alzav = np.zeros((ny,nMax))  # Area weights for cells near band line
    npzav = np.zeros(ny)     # Number of cells close to band line
    #for ij = 1:6*nc*nc                # Loop over all cells
    for ij in range(npoints):
        delta = (yc2[ij]-ylat[0])/dy  # Latitude difference from bottom
        jz = 1 + np.floor(delta)              # Number of zonal lines away (round up)
        delta = delta % 1               # Fracional distance from upper line
        if jz < 1:
            n = npzav[jz] + 1   # Contribution from cell NORTH of line
            ijzav[jz,n-1] = ij
            alzav[jz,n-1] = 1     # Weight = 1 because all area accounted for
            npzav[jz] = n 
        elif jz >= ny:
            n = npzav[jz-1] + 1     # Contribution from cell NORTH of line
            ijzav[jz-1,n-1] = ij
            alzav[jz-1,n-1] = 1       # Weight = 1 because all area accounted for
            npzav[jz-1] = n
        else:
            n = npzav[jz-1] + 1;     # Contribution from cell SOUTH of line
            ijzav[jz-1,n-1] = ij
            alzav[jz-1,n-1] = 1 - delta
            npzav[jz-1] = n
            n = npzav[jz] + 1   # Contribution from cell NORTH of line
            ijzav[jz,n-1] = ij
            alzav[jz,n-1] = delta
            npzav[jz] = n
    NbMx = np.max(npzav)  # Reduce size
    ijzav = ijzav[:,:NbMx]
    alzav = alzav[:,:NbMx]
    
    #  this doesn't seem to be used anywhere in matlab code
    #mskC = np.ceil(hc2)  # Cell centered mask:  1 = any land, 0 = no land
        
    # Basin stuff:
        #  removed from this version, never use it anyway
        
    # Area associated with zonal lines:
    areazon = np.zeros(ny)
    for j in range(ny):
        ijLoc = ijzav[j,:npzav[j]]
        vvLoc = alzav[j,:npzav[j]]  #';
        areazon[j] = np.sum(vvLoc * ar2[ijLoc])
    
    # in matlab code, mskzon was calculate in the basin block
    #  it's an area mask per basin and per level. with nBas = 0 it's identical to areazon
    #  but only for a single flat bottomed basin!
    #  will need to do more work here if we want to take proper basin averages
    mskLoc = areazon
    
    # Compute zonal average:
    fldzon = np.zeros((ny,nr,nt))
    vv1 = ar2
    for it in range(nt):
        fld1t = fld2[:,:,it]
        #for nb = 1:1+abs(nBas),
            #if nb == 1, vv1 = ar;
            #else        vv1 = ar.*mskB(:,nb-1); end
        for k in range(nr):
                #if nBas < 0, mskLoc=mskzon(:,nb);
                #else         mskLoc=mskzon(:,k,nb); end
            var = vv1 * hc2[:,k]
            var = var * fld1t[:,k]
            for j in range(ny):
                if mskLoc[j] > frcZmn*areazon[j]:
                    ijLoc=ijzav[j,:npzav[j]]
                    vvLoc=alzav[j,:npzav[j]]
                    fldzon[j,k,it] = np.sum(vvLoc*var[ijLoc])/mskLoc[j]
                else:
                    fldzon[j,k,it] = np.nan

#    if len(dims) > nDim:
#        fldzon = reshape(fldzon,[ny nr 1+abs(nBas) dims(nDim:end)]);
    
    fldzon = np.squeeze(fldzon)
    
    return fldzon,ylat,areazon